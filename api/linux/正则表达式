(?=exp)零宽度正预测先行断言，断言自身出现位置的-后面能匹配exp.
 返回与exp匹配的前面位置，从左到右匹配。当exp在此位置的右侧匹配时才继续匹配。
\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分（除了ing以外的部分）
?=将向前查找（查找出现在被匹配文本之后的支付，但不消费那个字符）

(?<=exp)零宽度正回顾后发断言，断言自身出现位置的-前面能匹配exp.
返回与exp匹配的后边位置，从右到左匹配。当exp在此位置的左侧匹配时才继续匹配。
(?<=\bre)\w+\b，匹配以re开头的单词的后半部分（除了re以外的部分）
(?<=Red-)\w+，匹配Red- 后边的单词。

可以想象在模式匹配过程中有一指针标志当前匹配的位置，当exp匹配时：
预测先行-把指针指到exp前边，回顾后发-则放到exp后边。

消费consume来表述“匹配和返回文本”的含义。被匹配的文本不包含在最终返回的匹配
结果，这被称为不消费。

向前和向后查找匹配本身其实是有返回结果的，只是这个结果的字节长度永远是0而已，
因此前后查找操作有时也被称为零宽度（zero-width）匹配操作。

任何一个子表达式都可以转换为一个向前查找表达式，只要给它加一个?=前缀即可。

嵌入条件的两种情况：根据回溯引用和前后查找进行条件处理。

<td>
<a href="/home"><img src="/images/home.gif"></a>
<img src="/images/spacer.gif">
<a href="/serach"><img src="/images/serach.gif"></a>
<img src="/images/search.gif">
<a href="/help"><img src="/images/help.gif"></a>
</td>

(<a\s+[^>]+\s*)?<img\s+[^>]+>(?(1)\s*</a>)


js中表单验证常用到的正则表达式 
正则表达式中的常用模式
下面是正则表达式中的一些常用模式。

/pattern/  结果  
. 匹配除换行符以外的所有字符 
x? 匹配 0 次或一次 x 字符串 
x* 匹配 0 次或多次 x 字符串，但匹配可能的最少次数 
x+ 匹配 1 次或多次 x 字符串，但匹配可能的最少次数 
.* 匹配 0 次或一次的任何字符 
.+ 匹配 1 次或多次的任何字符 
{m} 匹配刚好是 m 个 的指定字符串 
{m,n} 匹配在 m个 以上 n个 以下 的指定字符串 
{m,} 匹配 m个 以上 的指定字符串 
[] 匹配符合 [] 内的字符 
[^] 匹配不符合 [] 内的字符 
[0-9] 匹配所有数字字符 
[a-z] 匹配所有小写字母字符 
[^0-9] 匹配所有非数字字符 
[^a-z] 匹配所有非小写字母字符 
^ 匹配字符开头的字符 
$ 匹配字符结尾的字符 
\d 匹配一个数字的字符，和 [0-9] 语法一样 
\d+ 匹配多个数字字符串，和 [0-9]+ 语法一样 
\D 非数字，其他同 \d 
\D+ 非数字，其他同 \d+ 
\w 英文字母或数字的字符串，和 [a-zA-Z0-9] 语法一样 
\w+ 和 [a-zA-Z0-9]+ 语法一样 
\W 非英文字母或数字的字符串，和 [^a-zA-Z0-9] 语法一样 
\W+ 和 [^a-zA-Z0-9]+ 语法一样 
\s 空格，和 [\n\t\r\f] 语法一样 
\s+ 和 [\n\t\r\f]+ 一样 
\S 非空格，和 [^\n\t\r\f] 语法一样 
\S+ 和 [^\n\t\r\f]+ 语法一样 
\b 匹配以英文字母,数字为边界的字符串 
\B 匹配不以英文字母,数值为边界的字符串 
a|b|c 匹配符合a字符 或是b字符 或是c字符 的字符串 
abc 匹配含有 abc 的字符串 
(pattern) () 这个符号会记住所找寻到的字符串，是一个很实用的语法。第一个 () 内所找到的字符串变成 $1 这个变量或是 \1 变量，第二个 () 内所找到的字符串变成 $2 这个变量或是 \2 变量，以此类推下去。  
/pattern/i i 这个参数表示忽略英文大小写，也就是在匹配字符串的时候，不考虑英文的大小写问题。 
\ 如果要在 pattern 模式中找寻一个特殊字符，如 "*"，则要在这个字符前加上 \ 符号，这样才会让特殊字符失效 
 


下面给出一些例子：    

范例 说明 
/perl/ 找到含有 perl 的字符串 
/^perl/ 找到开头是 perl 的字符串 
/perl$/ 找到结尾是 perl 的字符串 
/c|g|i/ 找到含有 c 或 g 或 i 的字符串 
/cg{2,4}i/ 找到 c 后面跟着 2个到 4个 g ，再跟着 i 的字符串 
/cg{2,}i/ 找到 c 后面跟着 2个以上 g ，再跟着 i 的字符串 
/cg{2}i/ 找到 c 后面跟着 2个 g，再跟着 i 的字符串 
/cg*i/ 找到 c 后面跟着 0个或多个 g ，再跟着 i 的字符串，如同/cg{0,1}i/ 
/cg+i/ 找到 c 后面跟着一个以上 g，再跟着 i 的字符串，如同/cg{1,}i/ 
/cg?i/ 找到 c 后面跟着 0个或是 1个 g ，再跟着 i 的字符串，如同/cg{0,1}i/ 
/c.i/ 找到 c 后面跟着一个任意字符，再跟着 i 的字符串 
/c..i/ 找到 c 后面跟着二个任意字符，再跟着 i 的字符串 
/[cgi]/ 找到符合有这三个字符任意一个的字符串 
/[^cgi]/ 找到没有这三个字符中任意一个的字符串 
/\d/ 找寻符合数字的字符，可以使用/\d+/来表示一个或是多个数字组成的字符串 
/\D/ 找寻符合不是数字的字符，可以使用/\D+/来表示一个或是更多个非数字组成的字符串 
/\*/ 找寻符合 * 这个字符，因为 * 在常规表达式中有它的特殊意思，所以要在这个特殊符号前加上 \ 符号，这样才会让这个特殊字符失效 
/abc/i 找寻符合 abc 的字符串而且不考虑这些字符串的大小写 


 

一些常用的表单验证正则表达式
Require: /.+/,
Email    : /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/,
Phone    : /^((\(\d{2,3}\))|(\d{3}\-))?(\(0\d{2,3}\)|0\d{2,3}-)?[1-9]\d{6,7}(\-\d{1,4})?$/,
Mobile : /^((\(\d{2,3}\))|(\d{3}\-))?13\d{9}$/,
Url : /^http:\/\/[A-Za-z0-9]+\.[A-Za-z0-9]+[\/=\?%\-&_~`@[\]\':+!]*([^<>\"\"])*$/,
Currency: /^\d+(\.\d+)?$/,
Number : /^\d+$/,
Zip      : /^[1-9]\d{5}$/,
QQ       : /^[1-9]\d{4,8}$/,
Integer: /^[-\+]?\d+$/,
Double : /^[-\+]?\d+(\.\d+)?$/,
English: /^[A-Za-z]+$/,
Chinese: /^[\u0391-\uFFE5]+$/,
Username:/^[a-z]\w{3,}$/i,
UnSafe : /^(([A-Z]*|[a-z]*|\d*|[-_\~!@#\$%\^&\*\.\(\)\[\]\{\}<>\?\\\/\'\"]*)|.{0,5})$|\s/,

 

匹配中文字符的正则表达式： 
评注：匹配中文还真是个头疼的事，有了这个表达式就好办了 

匹配双字节字符(包括汉字在内)：[^x00-xff] 
评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 

匹配空白行的正则表达式：ns*r 
评注：可以用来删除空白行 

匹配HTML标记的正则表达式：<(S*?)[^>]*>.*?|<.*? /> 
评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 

匹配首尾空白字符的正则表达式：^s*|s*$ 
评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 

匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)* 
评注：表单验证时很实用 

匹配网址URL的正则表达式：[a-zA-z]+://[^s]* 
评注：网上流传的版本功能很有限，上面这个基本可以满足需求 

匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 
评注：表单验证时很实用 

匹配国内电话号码：d{3}-d{8}|d{4}-d{7} 
评注：匹配形式如 0511-4405222 或 021-87888822 

匹配腾讯QQ号：[1-9][0-9]{4,} 
评注：腾讯QQ号从10000开始 

匹配中国邮政编码：[1-9]d{5}(?!d) 
评注：中国邮政编码为6位数字 

匹配身份证：d{15}|d{18} 
评注：中国的身份证为15位或18位 

匹配ip地址：d+.d+.d+.d+ 
评注：提取ip地址时有用 

匹配特定数字： 
^[1-9]d*$　 　 //匹配正整数 
^-[1-9]d*$ 　 //匹配负整数 
^-?[1-9]d*$　　 //匹配整数 
^[1-9]d*|0$　 //匹配非负整数（正整数 + 0） 
^-[1-9]d*|0$　　 //匹配非正整数（负整数 + 0） 
^[1-9]d*.d*|0.d*[1-9]d*$　　 //匹配正浮点数 
^-([1-9]d*.d*|0.d*[1-9]d*)$　 //匹配负浮点数 
^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$　 //匹配浮点数 
^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0） 
^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0） 
评注：处理大量数据时有用，具体应用时注意修正 

匹配特定字符串： 
^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串 
^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串 
^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串 
^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串 
^w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串 

在使用RegularExpressionValidator验证控件时的验证功能及其验证表达式介绍如下: 
只能输入数字：“^[0-9]*$” 
只能输入n位的数字：“^d{n}$” 
只能输入至少n位数字：“^d{n,}$” 
只能输入m-n位的数字：“^d{m,n}$” 
只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$” 
只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$” 
只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$” 
只能输入非零的正整数：“^+?[1-9][0-9]*$” 
只能输入非零的负整数：“^-[1-9][0-9]*$” 
只能输入长度为3的字符：“^.{3}$” 
只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$” 
只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$” 
只能输入由26个小写英文字母组成的字符串：“^[a-z]+$” 
只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$” 
只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$” 

验证用户密码:“^[a-zA-Z]w{5,17}$”正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。 
验证是否含有^%&’,;=?$”等字符：“[^%&’,;=?$x22]+” 
只能输入汉字：“^[u4e00-u9fa5],{0,}$” 
验证Email地址：“^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$” 
验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&=]*)?$” 
验证电话号码：“^((d{3,4})|d{3,4}-)?d{7,8}$” 
正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”， 
“XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。 
验证身份证号（15位或18位数字）：“^d{15}|d{}18$” 
验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12” 
验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$” 
正确格式为：“01”“09”和“1”“31”。 
匹配中文字符的正则表达式： 
匹配双字节字符(包括汉字在内)：[^x00-xff] 
匹配空行的正则表达式：n[s| ]*r 
匹配HTML标记的正则表达式：/<(.*)>.*<!--1-->|<(.*) />/ 
匹配首尾空格的正则表达式：(^s*)|(s*$) 
匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)* 
匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&=]*)? 

(1)应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 
String.prototype.len=function(){return this.replace([^x00-xff]/g,”aa”).length;} 
(2)应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现 
String.prototype.trim = function() 
{ 
return this.replace(/(^s*)|(s*$)/g, “”); 
} 
(3)应用：利用正则表达式分解和转换IP地址 
function IP2V(ip) //IP地址转换成对应数值 
{ 
re=/(d+).(d+).(d+).(d+)/g //匹配IP地址的正则表达式 
if(re.test(ip)) 
{ 
return RegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1 
} 
else 
{ 
throw new Error(”Not a valid IP address!”) 
} 
} 
(4)应用：从URL地址中提取文件名的javascript程序 
s=”http://www.9499.net/page1.htm”; 
s=s.replace(/(.*/){0,}([^.]+).*/ig,”$2″) ; //Page1.htm 
(5)应用：利用正则表达式限制网页表单里的文本框输入内容用正则表达式限制只能输入中文：onkeyup=”value=”/blog/value.replace(/[”^u4E00-u9FA5]/g, '’) ” onbeforepaste=”clipboardData.setData(’text’,clipboardData.getData(’text’).replace(/[^u4E00-u9FA5]/g,'’))” 
用正则表达式限制只能输入全角字符： onkeyup=”value=”/blog/value.replace(/[”^uFF00-uFFFF]/g,'’) ” onbeforepaste=”clipboardData.setData(’text’,clipboardData.getData(’text’).replace(/[^uFF00-uFFFF]/g,'’))” 
用正则表达式限制只能输入数字：onkeyup=”value=”/blog/value.replace(/[”^d]/g,'’) “onbeforepaste= “clipboardData.setData(’text’,clipboardData.getData(’text’).replace(/[^d]/g,'’))” 
用正则表达式限制只能输入数字和英文：onkeyup=”value=”/blog/value.replace(/[W]/g,”‘’) “onbeforepaste=”clipboardData.setData(’text’,clipboardData.getData(’text’).replace(/[^d]/g,'’ 
 
 function isSafe(str){
   var reg = /^.*[\'|\"|\/|<|>].*$/;
   return  !reg.test(str);   
 }

html:
<("[^"]*"|'[^']*'|[^'">])*>